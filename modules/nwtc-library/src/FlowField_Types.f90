!STARTOFREGISTRYGENERATEDFILE 'FlowField_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry.
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry
!*********************************************************************************************************************************
! FlowField_Types
!.................................................................................................................................
! This file is part of FlowField.
!
! Copyright (C) 2012-2016 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
!> This module contains the user-defined types needed in FlowField. It also contains copy, destroy, pack, and
!! unpack routines associated with each defined data type. This code is automatically generated by the FAST Registry.
MODULE FlowField_Types
!---------------------------------------------------------------------------------------------------------------------------------
USE NWTC_Library
IMPLICIT NONE
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Undef_FieldType = 0      ! This is the code for an undefined FieldType [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Uniform_FieldType = 1      ! Uniform FieldType from SteadyWind or Uniform Wind [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Grid_FieldType = 2      ! Grid-Field FieldType from TurbSim, Bladed, HAWC [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: User_FieldType = 3      ! User FieldType configured by the user [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: External_FieldType = 4      ! External FieldType from OpFM or similar [-]
! =========  UniformFieldType  =======
  TYPE, PUBLIC :: UniformFieldType
    REAL(ReKi)  :: RefHeight      !< reference height; used to center the wind [meters]
    REAL(ReKi)  :: RefLength      !< reference length used to scale the linear shear [meters]
    INTEGER(IntKi)  :: DataSize      !< size of data in HH file [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Time      !< HH time array [seconds]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: VelH      !< HH horizontal wind speed [meters/sec]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: VelV      !< HH vertical wind speed, including tower shadow [meters/sec]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: VelGust      !< HH wind gust speed [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: AngleH      !< HH wind direction angle [degrees]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: AngleV      !< HH upflow angle [degrees]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: ShrH      !< HH horizontal linear shear [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: ShrV      !< HH vertical shear exponent [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LinShrV      !< HH vertical linear shear [seconds]
  END TYPE UniformFieldType
! =======================
! =========  UniformField_Interp  =======
  TYPE, PUBLIC :: UniformField_Interp
    INTEGER(IntKi)  :: IData      !< Data index high [-]
    REAL(ReKi)  :: dt      !< interval delta time [seconds]
    REAL(ReKi)  :: Time      !< HH time [seconds]
    REAL(ReKi)  :: VelH      !< HH horizontal wind speed [meters/sec]
    REAL(ReKi)  :: VelV      !< HH vertical wind speed, including tower shadow [meters/sec]
    REAL(ReKi)  :: VelGust      !< HH wind gust speed [-]
    REAL(ReKi)  :: AngleH      !< HH wind direction angle [degrees]
    REAL(ReKi)  :: AngleV      !< HH upflow angle [degrees]
    REAL(ReKi)  :: ShrH      !< HH horizontal linear shear [-]
    REAL(ReKi)  :: ShrV      !< HH vertical shear exponent [-]
    REAL(ReKi)  :: LinShrV      !< HH vertical linear shear [seconds]
    REAL(ReKi)  :: CosAngleH      !< Horizontal angle components [-]
    REAL(ReKi)  :: SinAngleH      !< Horizontal angle components [-]
    REAL(ReKi)  :: CosAngleV      !< Vertical angle components [-]
    REAL(ReKi)  :: SinAngleV      !< Vertical angle components [-]
  END TYPE UniformField_Interp
! =======================
! =========  GridFieldType  =======
  TYPE, PUBLIC :: GridFieldType
    INTEGER(IntKi)  :: WindFileFormat      !< Binary file format description number [-]
    INTEGER(IntKi)  :: WindProfileType = -1      !< Wind profile type (0=constant;1=logarithmic;2=power law) [-]
    LOGICAL  :: Periodic = .false.      !< Flag to indicate if the wind file is periodic [-]
    LOGICAL  :: InterpTower = .false.      !< Flag to indicate if we should interpolate wind speeds below the tower [-]
    LOGICAL  :: AddMeanAfterInterp = .false.      !< Add the mean wind speed after interpolating at a given height? [-]
    REAL(ReKi)  :: RefHeight = 0      !< Reference (hub) height of the grid [meters]
    REAL(SiKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: Vel      !< Array of field velocities [-]
    REAL(SiKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: Acc      !< Array of field accelerations [-]
    REAL(SiKi) , DIMENSION(:,:,:), ALLOCATABLE  :: VelTower      !< Array of tower velocities [-]
    REAL(SiKi) , DIMENSION(:,:,:), ALLOCATABLE  :: AccTower      !< Array of tower accelerations [-]
    REAL(ReKi)  :: DTime = 0      !< Delta time [seconds]
    REAL(ReKi)  :: Rate = 0      !< Data rate (1/FFDTime) [Hertz]
    REAL(ReKi)  :: YHWid = 0      !< Half the grid width [meters]
    REAL(ReKi)  :: ZHWid = 0      !< Half the grid height [meters]
    REAL(ReKi)  :: GridBase = 0      !< the height of the bottom of the grid [meters]
    REAL(ReKi)  :: InitXPosition = 0      !< the initial x position of grid (distance in FF is offset) [meters]
    REAL(ReKi)  :: InvDY = 0      !< reciprocal of delta y [1/meters]
    REAL(ReKi)  :: InvDZ = 0      !< reciprocal of delta z [1/meters]
    REAL(ReKi)  :: MeanWS = 0      !< Mean wind speed (as defined in FF file), not necessarily of the portion used [meters/second]
    REAL(ReKi)  :: InvMWS = 0      !< reciprocal of mean wind speed (MeanFFWS) [seconds/meter]
    REAL(ReKi)  :: TotalTime = 0      !< The total time of the simulation [seconds]
    INTEGER(IntKi)  :: NComp = 3      !< Number of wind components [-]
    INTEGER(IntKi)  :: NYGrids = 0      !< Number of points in the lateral (y) direction of the grids [-]
    INTEGER(IntKi)  :: NZGrids = 0      !< Number of points in the vertical (z) direction of the grids [-]
    INTEGER(IntKi)  :: NTGrids = 0      !< Number of points in the vertical (z) direction on the tower (below the grids) [-]
    INTEGER(IntKi)  :: NSteps = 0      !< Number of time steps in the FF array [-]
    REAL(ReKi)  :: PLExp = 0      !< Power law exponent (used for PL wind profile type only) [-]
    REAL(ReKi)  :: Z0 = 0      !< Surface roughness length (used for LOG wind profile type only) [-]
  END TYPE GridFieldType
! =======================
! =========  ExternalFieldType  =======
  TYPE, PUBLIC :: ExternalFieldType
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Vel      !< Wind velocities populated by external driver [-]
  END TYPE ExternalFieldType
! =======================
! =========  UserFieldType  =======
  TYPE, PUBLIC :: UserFieldType
    REAL(SiKi)  :: Dummy      !<  [-]
  END TYPE UserFieldType
! =======================
! =========  FlowFieldType  =======
  TYPE, PUBLIC :: FlowFieldType
    INTEGER(IntKi)  :: FieldType = 0      !< Switch for flow field type {1=Uniform, 2=Grid, 3=User, 4=External} [-]
    REAL(ReKi) , DIMENSION(1:3)  :: RefPosition      !< Reference position (point where box is rotated) [meters]
    REAL(ReKi)  :: PropagationDir      !< Direction of wind propagation [radians]
    REAL(ReKi)  :: VFlowAngle      !< Vertical (upflow) angle [radians]
    LOGICAL  :: RotateWindBox = .false.      !< flag indicating if the wind will be rotated [-]
    REAL(ReKi) , DIMENSION(1:3,1:3)  :: RotToWind      !< Rotation matrix for rotating from the global XYZ coordinate system to the wind coordinate system (wind along X') [-]
    REAL(ReKi) , DIMENSION(1:3,1:3)  :: RotFromWind      !< Rotation matrix for rotating from the wind coordinate system (wind along X') back to the global XYZ coordinate system.  Equal to TRANSPOSE(RotToWind) [-]
    TYPE(UniformFieldType)  :: Uniform      !< Uniform Flow Data [-]
    TYPE(GridFieldType)  :: Grid      !< Grid Field Wind Data [-]
    TYPE(UserFieldType)  :: User      !< User Field Wind Data [-]
    TYPE(ExternalFieldType)  :: External      !< External Flow Data [-]
  END TYPE FlowFieldType
! =======================
CONTAINS
 SUBROUTINE FlowField_CopyUniformFieldType( SrcUniformFieldTypeData, DstUniformFieldTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(UniformFieldType), INTENT(IN) :: SrcUniformFieldTypeData
   TYPE(UniformFieldType), INTENT(INOUT) :: DstUniformFieldTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: i4, i4_l, i4_u  !  bounds (upper/lower) for an array dimension 4
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FlowField_CopyUniformFieldType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstUniformFieldTypeData%RefHeight = SrcUniformFieldTypeData%RefHeight
    DstUniformFieldTypeData%RefLength = SrcUniformFieldTypeData%RefLength
    DstUniformFieldTypeData%DataSize = SrcUniformFieldTypeData%DataSize
IF (ALLOCATED(SrcUniformFieldTypeData%Time)) THEN
  i1_l = LBOUND(SrcUniformFieldTypeData%Time,1)
  i1_u = UBOUND(SrcUniformFieldTypeData%Time,1)
  IF (.NOT. ALLOCATED(DstUniformFieldTypeData%Time)) THEN 
    ALLOCATE(DstUniformFieldTypeData%Time(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstUniformFieldTypeData%Time.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstUniformFieldTypeData%Time = SrcUniformFieldTypeData%Time
ENDIF
IF (ALLOCATED(SrcUniformFieldTypeData%VelH)) THEN
  i1_l = LBOUND(SrcUniformFieldTypeData%VelH,1)
  i1_u = UBOUND(SrcUniformFieldTypeData%VelH,1)
  IF (.NOT. ALLOCATED(DstUniformFieldTypeData%VelH)) THEN 
    ALLOCATE(DstUniformFieldTypeData%VelH(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstUniformFieldTypeData%VelH.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstUniformFieldTypeData%VelH = SrcUniformFieldTypeData%VelH
ENDIF
IF (ALLOCATED(SrcUniformFieldTypeData%VelV)) THEN
  i1_l = LBOUND(SrcUniformFieldTypeData%VelV,1)
  i1_u = UBOUND(SrcUniformFieldTypeData%VelV,1)
  IF (.NOT. ALLOCATED(DstUniformFieldTypeData%VelV)) THEN 
    ALLOCATE(DstUniformFieldTypeData%VelV(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstUniformFieldTypeData%VelV.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstUniformFieldTypeData%VelV = SrcUniformFieldTypeData%VelV
ENDIF
IF (ALLOCATED(SrcUniformFieldTypeData%VelGust)) THEN
  i1_l = LBOUND(SrcUniformFieldTypeData%VelGust,1)
  i1_u = UBOUND(SrcUniformFieldTypeData%VelGust,1)
  IF (.NOT. ALLOCATED(DstUniformFieldTypeData%VelGust)) THEN 
    ALLOCATE(DstUniformFieldTypeData%VelGust(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstUniformFieldTypeData%VelGust.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstUniformFieldTypeData%VelGust = SrcUniformFieldTypeData%VelGust
ENDIF
IF (ALLOCATED(SrcUniformFieldTypeData%AngleH)) THEN
  i1_l = LBOUND(SrcUniformFieldTypeData%AngleH,1)
  i1_u = UBOUND(SrcUniformFieldTypeData%AngleH,1)
  IF (.NOT. ALLOCATED(DstUniformFieldTypeData%AngleH)) THEN 
    ALLOCATE(DstUniformFieldTypeData%AngleH(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstUniformFieldTypeData%AngleH.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstUniformFieldTypeData%AngleH = SrcUniformFieldTypeData%AngleH
ENDIF
IF (ALLOCATED(SrcUniformFieldTypeData%AngleV)) THEN
  i1_l = LBOUND(SrcUniformFieldTypeData%AngleV,1)
  i1_u = UBOUND(SrcUniformFieldTypeData%AngleV,1)
  IF (.NOT. ALLOCATED(DstUniformFieldTypeData%AngleV)) THEN 
    ALLOCATE(DstUniformFieldTypeData%AngleV(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstUniformFieldTypeData%AngleV.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstUniformFieldTypeData%AngleV = SrcUniformFieldTypeData%AngleV
ENDIF
IF (ALLOCATED(SrcUniformFieldTypeData%ShrH)) THEN
  i1_l = LBOUND(SrcUniformFieldTypeData%ShrH,1)
  i1_u = UBOUND(SrcUniformFieldTypeData%ShrH,1)
  IF (.NOT. ALLOCATED(DstUniformFieldTypeData%ShrH)) THEN 
    ALLOCATE(DstUniformFieldTypeData%ShrH(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstUniformFieldTypeData%ShrH.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstUniformFieldTypeData%ShrH = SrcUniformFieldTypeData%ShrH
ENDIF
IF (ALLOCATED(SrcUniformFieldTypeData%ShrV)) THEN
  i1_l = LBOUND(SrcUniformFieldTypeData%ShrV,1)
  i1_u = UBOUND(SrcUniformFieldTypeData%ShrV,1)
  IF (.NOT. ALLOCATED(DstUniformFieldTypeData%ShrV)) THEN 
    ALLOCATE(DstUniformFieldTypeData%ShrV(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstUniformFieldTypeData%ShrV.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstUniformFieldTypeData%ShrV = SrcUniformFieldTypeData%ShrV
ENDIF
IF (ALLOCATED(SrcUniformFieldTypeData%LinShrV)) THEN
  i1_l = LBOUND(SrcUniformFieldTypeData%LinShrV,1)
  i1_u = UBOUND(SrcUniformFieldTypeData%LinShrV,1)
  IF (.NOT. ALLOCATED(DstUniformFieldTypeData%LinShrV)) THEN 
    ALLOCATE(DstUniformFieldTypeData%LinShrV(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstUniformFieldTypeData%LinShrV.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstUniformFieldTypeData%LinShrV = SrcUniformFieldTypeData%LinShrV
ENDIF
 END SUBROUTINE FlowField_CopyUniformFieldType

 SUBROUTINE FlowField_DestroyUniformFieldType( UniformFieldTypeData, ErrStat, ErrMsg, DEALLOCATEpointers )
  TYPE(UniformFieldType), INTENT(INOUT) :: UniformFieldTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL,INTENT(IN   ) :: DEALLOCATEpointers
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  LOGICAL                        :: DEALLOCATEpointers_local
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FlowField_DestroyUniformFieldType'

  ErrStat = ErrID_None
  ErrMsg  = ""

  IF (PRESENT(DEALLOCATEpointers)) THEN
     DEALLOCATEpointers_local = DEALLOCATEpointers
  ELSE
     DEALLOCATEpointers_local = .true.
  END IF
  
IF (ALLOCATED(UniformFieldTypeData%Time)) THEN
  DEALLOCATE(UniformFieldTypeData%Time)
ENDIF
IF (ALLOCATED(UniformFieldTypeData%VelH)) THEN
  DEALLOCATE(UniformFieldTypeData%VelH)
ENDIF
IF (ALLOCATED(UniformFieldTypeData%VelV)) THEN
  DEALLOCATE(UniformFieldTypeData%VelV)
ENDIF
IF (ALLOCATED(UniformFieldTypeData%VelGust)) THEN
  DEALLOCATE(UniformFieldTypeData%VelGust)
ENDIF
IF (ALLOCATED(UniformFieldTypeData%AngleH)) THEN
  DEALLOCATE(UniformFieldTypeData%AngleH)
ENDIF
IF (ALLOCATED(UniformFieldTypeData%AngleV)) THEN
  DEALLOCATE(UniformFieldTypeData%AngleV)
ENDIF
IF (ALLOCATED(UniformFieldTypeData%ShrH)) THEN
  DEALLOCATE(UniformFieldTypeData%ShrH)
ENDIF
IF (ALLOCATED(UniformFieldTypeData%ShrV)) THEN
  DEALLOCATE(UniformFieldTypeData%ShrV)
ENDIF
IF (ALLOCATED(UniformFieldTypeData%LinShrV)) THEN
  DEALLOCATE(UniformFieldTypeData%LinShrV)
ENDIF
 END SUBROUTINE FlowField_DestroyUniformFieldType

 SUBROUTINE FlowField_PackUniformFieldType( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(UniformFieldType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'FlowField_PackUniformFieldType'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Re_BufSz   = Re_BufSz   + 1  ! RefHeight
      Re_BufSz   = Re_BufSz   + 1  ! RefLength
      Int_BufSz  = Int_BufSz  + 1  ! DataSize
  Int_BufSz   = Int_BufSz   + 1     ! Time allocated yes/no
  IF ( ALLOCATED(InData%Time) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! Time upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Time)  ! Time
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! VelH allocated yes/no
  IF ( ALLOCATED(InData%VelH) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! VelH upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%VelH)  ! VelH
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! VelV allocated yes/no
  IF ( ALLOCATED(InData%VelV) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! VelV upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%VelV)  ! VelV
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! VelGust allocated yes/no
  IF ( ALLOCATED(InData%VelGust) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! VelGust upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%VelGust)  ! VelGust
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! AngleH allocated yes/no
  IF ( ALLOCATED(InData%AngleH) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! AngleH upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%AngleH)  ! AngleH
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! AngleV allocated yes/no
  IF ( ALLOCATED(InData%AngleV) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! AngleV upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%AngleV)  ! AngleV
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! ShrH allocated yes/no
  IF ( ALLOCATED(InData%ShrH) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! ShrH upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%ShrH)  ! ShrH
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! ShrV allocated yes/no
  IF ( ALLOCATED(InData%ShrV) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! ShrV upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%ShrV)  ! ShrV
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! LinShrV allocated yes/no
  IF ( ALLOCATED(InData%LinShrV) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! LinShrV upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%LinShrV)  ! LinShrV
  END IF
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    ReKiBuf(Re_Xferred) = InData%RefHeight
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%RefLength
    Re_Xferred = Re_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%DataSize
    Int_Xferred = Int_Xferred + 1
  IF ( .NOT. ALLOCATED(InData%Time) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Time,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Time,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%Time,1), UBOUND(InData%Time,1)
        ReKiBuf(Re_Xferred) = InData%Time(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%VelH) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%VelH,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%VelH,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%VelH,1), UBOUND(InData%VelH,1)
        ReKiBuf(Re_Xferred) = InData%VelH(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%VelV) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%VelV,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%VelV,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%VelV,1), UBOUND(InData%VelV,1)
        ReKiBuf(Re_Xferred) = InData%VelV(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%VelGust) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%VelGust,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%VelGust,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%VelGust,1), UBOUND(InData%VelGust,1)
        ReKiBuf(Re_Xferred) = InData%VelGust(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%AngleH) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%AngleH,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%AngleH,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%AngleH,1), UBOUND(InData%AngleH,1)
        ReKiBuf(Re_Xferred) = InData%AngleH(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%AngleV) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%AngleV,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%AngleV,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%AngleV,1), UBOUND(InData%AngleV,1)
        ReKiBuf(Re_Xferred) = InData%AngleV(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%ShrH) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%ShrH,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%ShrH,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%ShrH,1), UBOUND(InData%ShrH,1)
        ReKiBuf(Re_Xferred) = InData%ShrH(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%ShrV) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%ShrV,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%ShrV,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%ShrV,1), UBOUND(InData%ShrV,1)
        ReKiBuf(Re_Xferred) = InData%ShrV(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%LinShrV) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%LinShrV,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%LinShrV,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%LinShrV,1), UBOUND(InData%LinShrV,1)
        ReKiBuf(Re_Xferred) = InData%LinShrV(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
 END SUBROUTINE FlowField_PackUniformFieldType

 SUBROUTINE FlowField_UnPackUniformFieldType( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(UniformFieldType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
  INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
  INTEGER(IntKi)                 :: i4, i4_l, i4_u  !  bounds (upper/lower) for an array dimension 4
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'FlowField_UnPackUniformFieldType'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    OutData%RefHeight = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%RefLength = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%DataSize = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Time not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Time)) DEALLOCATE(OutData%Time)
    ALLOCATE(OutData%Time(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Time.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%Time,1), UBOUND(OutData%Time,1)
        OutData%Time(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! VelH not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%VelH)) DEALLOCATE(OutData%VelH)
    ALLOCATE(OutData%VelH(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%VelH.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%VelH,1), UBOUND(OutData%VelH,1)
        OutData%VelH(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! VelV not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%VelV)) DEALLOCATE(OutData%VelV)
    ALLOCATE(OutData%VelV(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%VelV.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%VelV,1), UBOUND(OutData%VelV,1)
        OutData%VelV(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! VelGust not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%VelGust)) DEALLOCATE(OutData%VelGust)
    ALLOCATE(OutData%VelGust(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%VelGust.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%VelGust,1), UBOUND(OutData%VelGust,1)
        OutData%VelGust(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! AngleH not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%AngleH)) DEALLOCATE(OutData%AngleH)
    ALLOCATE(OutData%AngleH(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%AngleH.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%AngleH,1), UBOUND(OutData%AngleH,1)
        OutData%AngleH(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! AngleV not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%AngleV)) DEALLOCATE(OutData%AngleV)
    ALLOCATE(OutData%AngleV(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%AngleV.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%AngleV,1), UBOUND(OutData%AngleV,1)
        OutData%AngleV(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! ShrH not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%ShrH)) DEALLOCATE(OutData%ShrH)
    ALLOCATE(OutData%ShrH(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%ShrH.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%ShrH,1), UBOUND(OutData%ShrH,1)
        OutData%ShrH(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! ShrV not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%ShrV)) DEALLOCATE(OutData%ShrV)
    ALLOCATE(OutData%ShrV(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%ShrV.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%ShrV,1), UBOUND(OutData%ShrV,1)
        OutData%ShrV(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! LinShrV not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%LinShrV)) DEALLOCATE(OutData%LinShrV)
    ALLOCATE(OutData%LinShrV(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%LinShrV.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%LinShrV,1), UBOUND(OutData%LinShrV,1)
        OutData%LinShrV(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
 END SUBROUTINE FlowField_UnPackUniformFieldType

 SUBROUTINE FlowField_CopyUniformField_Interp( SrcUniformField_InterpData, DstUniformField_InterpData, CtrlCode, ErrStat, ErrMsg )
   TYPE(UniformField_Interp), INTENT(IN) :: SrcUniformField_InterpData
   TYPE(UniformField_Interp), INTENT(INOUT) :: DstUniformField_InterpData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FlowField_CopyUniformField_Interp'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstUniformField_InterpData%IData = SrcUniformField_InterpData%IData
    DstUniformField_InterpData%dt = SrcUniformField_InterpData%dt
    DstUniformField_InterpData%Time = SrcUniformField_InterpData%Time
    DstUniformField_InterpData%VelH = SrcUniformField_InterpData%VelH
    DstUniformField_InterpData%VelV = SrcUniformField_InterpData%VelV
    DstUniformField_InterpData%VelGust = SrcUniformField_InterpData%VelGust
    DstUniformField_InterpData%AngleH = SrcUniformField_InterpData%AngleH
    DstUniformField_InterpData%AngleV = SrcUniformField_InterpData%AngleV
    DstUniformField_InterpData%ShrH = SrcUniformField_InterpData%ShrH
    DstUniformField_InterpData%ShrV = SrcUniformField_InterpData%ShrV
    DstUniformField_InterpData%LinShrV = SrcUniformField_InterpData%LinShrV
    DstUniformField_InterpData%CosAngleH = SrcUniformField_InterpData%CosAngleH
    DstUniformField_InterpData%SinAngleH = SrcUniformField_InterpData%SinAngleH
    DstUniformField_InterpData%CosAngleV = SrcUniformField_InterpData%CosAngleV
    DstUniformField_InterpData%SinAngleV = SrcUniformField_InterpData%SinAngleV
 END SUBROUTINE FlowField_CopyUniformField_Interp

 SUBROUTINE FlowField_DestroyUniformField_Interp( UniformField_InterpData, ErrStat, ErrMsg, DEALLOCATEpointers )
  TYPE(UniformField_Interp), INTENT(INOUT) :: UniformField_InterpData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL,INTENT(IN   ) :: DEALLOCATEpointers
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  LOGICAL                        :: DEALLOCATEpointers_local
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FlowField_DestroyUniformField_Interp'

  ErrStat = ErrID_None
  ErrMsg  = ""

  IF (PRESENT(DEALLOCATEpointers)) THEN
     DEALLOCATEpointers_local = DEALLOCATEpointers
  ELSE
     DEALLOCATEpointers_local = .true.
  END IF
  
 END SUBROUTINE FlowField_DestroyUniformField_Interp

 SUBROUTINE FlowField_PackUniformField_Interp( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(UniformField_Interp),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'FlowField_PackUniformField_Interp'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Int_BufSz  = Int_BufSz  + 1  ! IData
      Re_BufSz   = Re_BufSz   + 1  ! dt
      Re_BufSz   = Re_BufSz   + 1  ! Time
      Re_BufSz   = Re_BufSz   + 1  ! VelH
      Re_BufSz   = Re_BufSz   + 1  ! VelV
      Re_BufSz   = Re_BufSz   + 1  ! VelGust
      Re_BufSz   = Re_BufSz   + 1  ! AngleH
      Re_BufSz   = Re_BufSz   + 1  ! AngleV
      Re_BufSz   = Re_BufSz   + 1  ! ShrH
      Re_BufSz   = Re_BufSz   + 1  ! ShrV
      Re_BufSz   = Re_BufSz   + 1  ! LinShrV
      Re_BufSz   = Re_BufSz   + 1  ! CosAngleH
      Re_BufSz   = Re_BufSz   + 1  ! SinAngleH
      Re_BufSz   = Re_BufSz   + 1  ! CosAngleV
      Re_BufSz   = Re_BufSz   + 1  ! SinAngleV
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    IntKiBuf(Int_Xferred) = InData%IData
    Int_Xferred = Int_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%dt
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%Time
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%VelH
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%VelV
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%VelGust
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%AngleH
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%AngleV
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%ShrH
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%ShrV
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%LinShrV
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%CosAngleH
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%SinAngleH
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%CosAngleV
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%SinAngleV
    Re_Xferred = Re_Xferred + 1
 END SUBROUTINE FlowField_PackUniformField_Interp

 SUBROUTINE FlowField_UnPackUniformField_Interp( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(UniformField_Interp), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'FlowField_UnPackUniformField_Interp'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    OutData%IData = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%dt = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%Time = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%VelH = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%VelV = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%VelGust = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%AngleH = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%AngleV = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%ShrH = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%ShrV = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%LinShrV = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%CosAngleH = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%SinAngleH = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%CosAngleV = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%SinAngleV = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
 END SUBROUTINE FlowField_UnPackUniformField_Interp

 SUBROUTINE FlowField_CopyGridFieldType( SrcGridFieldTypeData, DstGridFieldTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(GridFieldType), INTENT(IN) :: SrcGridFieldTypeData
   TYPE(GridFieldType), INTENT(INOUT) :: DstGridFieldTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: i4, i4_l, i4_u  !  bounds (upper/lower) for an array dimension 4
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FlowField_CopyGridFieldType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstGridFieldTypeData%WindFileFormat = SrcGridFieldTypeData%WindFileFormat
    DstGridFieldTypeData%WindProfileType = SrcGridFieldTypeData%WindProfileType
    DstGridFieldTypeData%Periodic = SrcGridFieldTypeData%Periodic
    DstGridFieldTypeData%InterpTower = SrcGridFieldTypeData%InterpTower
    DstGridFieldTypeData%AddMeanAfterInterp = SrcGridFieldTypeData%AddMeanAfterInterp
    DstGridFieldTypeData%RefHeight = SrcGridFieldTypeData%RefHeight
IF (ALLOCATED(SrcGridFieldTypeData%Vel)) THEN
  i1_l = LBOUND(SrcGridFieldTypeData%Vel,1)
  i1_u = UBOUND(SrcGridFieldTypeData%Vel,1)
  i2_l = LBOUND(SrcGridFieldTypeData%Vel,2)
  i2_u = UBOUND(SrcGridFieldTypeData%Vel,2)
  i3_l = LBOUND(SrcGridFieldTypeData%Vel,3)
  i3_u = UBOUND(SrcGridFieldTypeData%Vel,3)
  i4_l = LBOUND(SrcGridFieldTypeData%Vel,4)
  i4_u = UBOUND(SrcGridFieldTypeData%Vel,4)
  IF (.NOT. ALLOCATED(DstGridFieldTypeData%Vel)) THEN 
    ALLOCATE(DstGridFieldTypeData%Vel(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstGridFieldTypeData%Vel.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstGridFieldTypeData%Vel = SrcGridFieldTypeData%Vel
ENDIF
IF (ALLOCATED(SrcGridFieldTypeData%Acc)) THEN
  i1_l = LBOUND(SrcGridFieldTypeData%Acc,1)
  i1_u = UBOUND(SrcGridFieldTypeData%Acc,1)
  i2_l = LBOUND(SrcGridFieldTypeData%Acc,2)
  i2_u = UBOUND(SrcGridFieldTypeData%Acc,2)
  i3_l = LBOUND(SrcGridFieldTypeData%Acc,3)
  i3_u = UBOUND(SrcGridFieldTypeData%Acc,3)
  i4_l = LBOUND(SrcGridFieldTypeData%Acc,4)
  i4_u = UBOUND(SrcGridFieldTypeData%Acc,4)
  IF (.NOT. ALLOCATED(DstGridFieldTypeData%Acc)) THEN 
    ALLOCATE(DstGridFieldTypeData%Acc(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstGridFieldTypeData%Acc.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstGridFieldTypeData%Acc = SrcGridFieldTypeData%Acc
ENDIF
IF (ALLOCATED(SrcGridFieldTypeData%VelTower)) THEN
  i1_l = LBOUND(SrcGridFieldTypeData%VelTower,1)
  i1_u = UBOUND(SrcGridFieldTypeData%VelTower,1)
  i2_l = LBOUND(SrcGridFieldTypeData%VelTower,2)
  i2_u = UBOUND(SrcGridFieldTypeData%VelTower,2)
  i3_l = LBOUND(SrcGridFieldTypeData%VelTower,3)
  i3_u = UBOUND(SrcGridFieldTypeData%VelTower,3)
  IF (.NOT. ALLOCATED(DstGridFieldTypeData%VelTower)) THEN 
    ALLOCATE(DstGridFieldTypeData%VelTower(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstGridFieldTypeData%VelTower.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstGridFieldTypeData%VelTower = SrcGridFieldTypeData%VelTower
ENDIF
IF (ALLOCATED(SrcGridFieldTypeData%AccTower)) THEN
  i1_l = LBOUND(SrcGridFieldTypeData%AccTower,1)
  i1_u = UBOUND(SrcGridFieldTypeData%AccTower,1)
  i2_l = LBOUND(SrcGridFieldTypeData%AccTower,2)
  i2_u = UBOUND(SrcGridFieldTypeData%AccTower,2)
  i3_l = LBOUND(SrcGridFieldTypeData%AccTower,3)
  i3_u = UBOUND(SrcGridFieldTypeData%AccTower,3)
  IF (.NOT. ALLOCATED(DstGridFieldTypeData%AccTower)) THEN 
    ALLOCATE(DstGridFieldTypeData%AccTower(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstGridFieldTypeData%AccTower.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstGridFieldTypeData%AccTower = SrcGridFieldTypeData%AccTower
ENDIF
    DstGridFieldTypeData%DTime = SrcGridFieldTypeData%DTime
    DstGridFieldTypeData%Rate = SrcGridFieldTypeData%Rate
    DstGridFieldTypeData%YHWid = SrcGridFieldTypeData%YHWid
    DstGridFieldTypeData%ZHWid = SrcGridFieldTypeData%ZHWid
    DstGridFieldTypeData%GridBase = SrcGridFieldTypeData%GridBase
    DstGridFieldTypeData%InitXPosition = SrcGridFieldTypeData%InitXPosition
    DstGridFieldTypeData%InvDY = SrcGridFieldTypeData%InvDY
    DstGridFieldTypeData%InvDZ = SrcGridFieldTypeData%InvDZ
    DstGridFieldTypeData%MeanWS = SrcGridFieldTypeData%MeanWS
    DstGridFieldTypeData%InvMWS = SrcGridFieldTypeData%InvMWS
    DstGridFieldTypeData%TotalTime = SrcGridFieldTypeData%TotalTime
    DstGridFieldTypeData%NComp = SrcGridFieldTypeData%NComp
    DstGridFieldTypeData%NYGrids = SrcGridFieldTypeData%NYGrids
    DstGridFieldTypeData%NZGrids = SrcGridFieldTypeData%NZGrids
    DstGridFieldTypeData%NTGrids = SrcGridFieldTypeData%NTGrids
    DstGridFieldTypeData%NSteps = SrcGridFieldTypeData%NSteps
    DstGridFieldTypeData%PLExp = SrcGridFieldTypeData%PLExp
    DstGridFieldTypeData%Z0 = SrcGridFieldTypeData%Z0
 END SUBROUTINE FlowField_CopyGridFieldType

 SUBROUTINE FlowField_DestroyGridFieldType( GridFieldTypeData, ErrStat, ErrMsg, DEALLOCATEpointers )
  TYPE(GridFieldType), INTENT(INOUT) :: GridFieldTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL,INTENT(IN   ) :: DEALLOCATEpointers
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  LOGICAL                        :: DEALLOCATEpointers_local
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FlowField_DestroyGridFieldType'

  ErrStat = ErrID_None
  ErrMsg  = ""

  IF (PRESENT(DEALLOCATEpointers)) THEN
     DEALLOCATEpointers_local = DEALLOCATEpointers
  ELSE
     DEALLOCATEpointers_local = .true.
  END IF
  
IF (ALLOCATED(GridFieldTypeData%Vel)) THEN
  DEALLOCATE(GridFieldTypeData%Vel)
ENDIF
IF (ALLOCATED(GridFieldTypeData%Acc)) THEN
  DEALLOCATE(GridFieldTypeData%Acc)
ENDIF
IF (ALLOCATED(GridFieldTypeData%VelTower)) THEN
  DEALLOCATE(GridFieldTypeData%VelTower)
ENDIF
IF (ALLOCATED(GridFieldTypeData%AccTower)) THEN
  DEALLOCATE(GridFieldTypeData%AccTower)
ENDIF
 END SUBROUTINE FlowField_DestroyGridFieldType

 SUBROUTINE FlowField_PackGridFieldType( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(GridFieldType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'FlowField_PackGridFieldType'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Int_BufSz  = Int_BufSz  + 1  ! WindFileFormat
      Int_BufSz  = Int_BufSz  + 1  ! WindProfileType
      Int_BufSz  = Int_BufSz  + 1  ! Periodic
      Int_BufSz  = Int_BufSz  + 1  ! InterpTower
      Int_BufSz  = Int_BufSz  + 1  ! AddMeanAfterInterp
      Re_BufSz   = Re_BufSz   + 1  ! RefHeight
  Int_BufSz   = Int_BufSz   + 1     ! Vel allocated yes/no
  IF ( ALLOCATED(InData%Vel) ) THEN
    Int_BufSz   = Int_BufSz   + 2*4  ! Vel upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Vel)  ! Vel
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Acc allocated yes/no
  IF ( ALLOCATED(InData%Acc) ) THEN
    Int_BufSz   = Int_BufSz   + 2*4  ! Acc upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Acc)  ! Acc
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! VelTower allocated yes/no
  IF ( ALLOCATED(InData%VelTower) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! VelTower upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%VelTower)  ! VelTower
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! AccTower allocated yes/no
  IF ( ALLOCATED(InData%AccTower) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! AccTower upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%AccTower)  ! AccTower
  END IF
      Re_BufSz   = Re_BufSz   + 1  ! DTime
      Re_BufSz   = Re_BufSz   + 1  ! Rate
      Re_BufSz   = Re_BufSz   + 1  ! YHWid
      Re_BufSz   = Re_BufSz   + 1  ! ZHWid
      Re_BufSz   = Re_BufSz   + 1  ! GridBase
      Re_BufSz   = Re_BufSz   + 1  ! InitXPosition
      Re_BufSz   = Re_BufSz   + 1  ! InvDY
      Re_BufSz   = Re_BufSz   + 1  ! InvDZ
      Re_BufSz   = Re_BufSz   + 1  ! MeanWS
      Re_BufSz   = Re_BufSz   + 1  ! InvMWS
      Re_BufSz   = Re_BufSz   + 1  ! TotalTime
      Int_BufSz  = Int_BufSz  + 1  ! NComp
      Int_BufSz  = Int_BufSz  + 1  ! NYGrids
      Int_BufSz  = Int_BufSz  + 1  ! NZGrids
      Int_BufSz  = Int_BufSz  + 1  ! NTGrids
      Int_BufSz  = Int_BufSz  + 1  ! NSteps
      Re_BufSz   = Re_BufSz   + 1  ! PLExp
      Re_BufSz   = Re_BufSz   + 1  ! Z0
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    IntKiBuf(Int_Xferred) = InData%WindFileFormat
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%WindProfileType
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = TRANSFER(InData%Periodic, IntKiBuf(1))
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = TRANSFER(InData%InterpTower, IntKiBuf(1))
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = TRANSFER(InData%AddMeanAfterInterp, IntKiBuf(1))
    Int_Xferred = Int_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%RefHeight
    Re_Xferred = Re_Xferred + 1
  IF ( .NOT. ALLOCATED(InData%Vel) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vel,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vel,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vel,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vel,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vel,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vel,3)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vel,4)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vel,4)
    Int_Xferred = Int_Xferred + 2

      DO i4 = LBOUND(InData%Vel,4), UBOUND(InData%Vel,4)
        DO i3 = LBOUND(InData%Vel,3), UBOUND(InData%Vel,3)
          DO i2 = LBOUND(InData%Vel,2), UBOUND(InData%Vel,2)
            DO i1 = LBOUND(InData%Vel,1), UBOUND(InData%Vel,1)
              ReKiBuf(Re_Xferred) = InData%Vel(i1,i2,i3,i4)
              Re_Xferred = Re_Xferred + 1
            END DO
          END DO
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%Acc) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Acc,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Acc,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Acc,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Acc,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Acc,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Acc,3)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Acc,4)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Acc,4)
    Int_Xferred = Int_Xferred + 2

      DO i4 = LBOUND(InData%Acc,4), UBOUND(InData%Acc,4)
        DO i3 = LBOUND(InData%Acc,3), UBOUND(InData%Acc,3)
          DO i2 = LBOUND(InData%Acc,2), UBOUND(InData%Acc,2)
            DO i1 = LBOUND(InData%Acc,1), UBOUND(InData%Acc,1)
              ReKiBuf(Re_Xferred) = InData%Acc(i1,i2,i3,i4)
              Re_Xferred = Re_Xferred + 1
            END DO
          END DO
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%VelTower) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%VelTower,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%VelTower,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%VelTower,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%VelTower,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%VelTower,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%VelTower,3)
    Int_Xferred = Int_Xferred + 2

      DO i3 = LBOUND(InData%VelTower,3), UBOUND(InData%VelTower,3)
        DO i2 = LBOUND(InData%VelTower,2), UBOUND(InData%VelTower,2)
          DO i1 = LBOUND(InData%VelTower,1), UBOUND(InData%VelTower,1)
            ReKiBuf(Re_Xferred) = InData%VelTower(i1,i2,i3)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%AccTower) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%AccTower,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%AccTower,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%AccTower,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%AccTower,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%AccTower,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%AccTower,3)
    Int_Xferred = Int_Xferred + 2

      DO i3 = LBOUND(InData%AccTower,3), UBOUND(InData%AccTower,3)
        DO i2 = LBOUND(InData%AccTower,2), UBOUND(InData%AccTower,2)
          DO i1 = LBOUND(InData%AccTower,1), UBOUND(InData%AccTower,1)
            ReKiBuf(Re_Xferred) = InData%AccTower(i1,i2,i3)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
    ReKiBuf(Re_Xferred) = InData%DTime
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%Rate
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%YHWid
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%ZHWid
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%GridBase
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%InitXPosition
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%InvDY
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%InvDZ
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%MeanWS
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%InvMWS
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%TotalTime
    Re_Xferred = Re_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%NComp
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%NYGrids
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%NZGrids
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%NTGrids
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%NSteps
    Int_Xferred = Int_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%PLExp
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%Z0
    Re_Xferred = Re_Xferred + 1
 END SUBROUTINE FlowField_PackGridFieldType

 SUBROUTINE FlowField_UnPackGridFieldType( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(GridFieldType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
  INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
  INTEGER(IntKi)                 :: i4, i4_l, i4_u  !  bounds (upper/lower) for an array dimension 4
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'FlowField_UnPackGridFieldType'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    OutData%WindFileFormat = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%WindProfileType = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%Periodic = TRANSFER(IntKiBuf(Int_Xferred), OutData%Periodic)
    Int_Xferred = Int_Xferred + 1
    OutData%InterpTower = TRANSFER(IntKiBuf(Int_Xferred), OutData%InterpTower)
    Int_Xferred = Int_Xferred + 1
    OutData%AddMeanAfterInterp = TRANSFER(IntKiBuf(Int_Xferred), OutData%AddMeanAfterInterp)
    Int_Xferred = Int_Xferred + 1
    OutData%RefHeight = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Vel not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i4_l = IntKiBuf( Int_Xferred    )
    i4_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Vel)) DEALLOCATE(OutData%Vel)
    ALLOCATE(OutData%Vel(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vel.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i4 = LBOUND(OutData%Vel,4), UBOUND(OutData%Vel,4)
        DO i3 = LBOUND(OutData%Vel,3), UBOUND(OutData%Vel,3)
          DO i2 = LBOUND(OutData%Vel,2), UBOUND(OutData%Vel,2)
            DO i1 = LBOUND(OutData%Vel,1), UBOUND(OutData%Vel,1)
              OutData%Vel(i1,i2,i3,i4) = REAL(ReKiBuf(Re_Xferred), SiKi)
              Re_Xferred = Re_Xferred + 1
            END DO
          END DO
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Acc not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i4_l = IntKiBuf( Int_Xferred    )
    i4_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Acc)) DEALLOCATE(OutData%Acc)
    ALLOCATE(OutData%Acc(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Acc.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i4 = LBOUND(OutData%Acc,4), UBOUND(OutData%Acc,4)
        DO i3 = LBOUND(OutData%Acc,3), UBOUND(OutData%Acc,3)
          DO i2 = LBOUND(OutData%Acc,2), UBOUND(OutData%Acc,2)
            DO i1 = LBOUND(OutData%Acc,1), UBOUND(OutData%Acc,1)
              OutData%Acc(i1,i2,i3,i4) = REAL(ReKiBuf(Re_Xferred), SiKi)
              Re_Xferred = Re_Xferred + 1
            END DO
          END DO
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! VelTower not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%VelTower)) DEALLOCATE(OutData%VelTower)
    ALLOCATE(OutData%VelTower(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%VelTower.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i3 = LBOUND(OutData%VelTower,3), UBOUND(OutData%VelTower,3)
        DO i2 = LBOUND(OutData%VelTower,2), UBOUND(OutData%VelTower,2)
          DO i1 = LBOUND(OutData%VelTower,1), UBOUND(OutData%VelTower,1)
            OutData%VelTower(i1,i2,i3) = REAL(ReKiBuf(Re_Xferred), SiKi)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! AccTower not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%AccTower)) DEALLOCATE(OutData%AccTower)
    ALLOCATE(OutData%AccTower(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%AccTower.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i3 = LBOUND(OutData%AccTower,3), UBOUND(OutData%AccTower,3)
        DO i2 = LBOUND(OutData%AccTower,2), UBOUND(OutData%AccTower,2)
          DO i1 = LBOUND(OutData%AccTower,1), UBOUND(OutData%AccTower,1)
            OutData%AccTower(i1,i2,i3) = REAL(ReKiBuf(Re_Xferred), SiKi)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
    OutData%DTime = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%Rate = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%YHWid = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%ZHWid = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%GridBase = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%InitXPosition = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%InvDY = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%InvDZ = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%MeanWS = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%InvMWS = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%TotalTime = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%NComp = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%NYGrids = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%NZGrids = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%NTGrids = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%NSteps = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%PLExp = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%Z0 = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
 END SUBROUTINE FlowField_UnPackGridFieldType

 SUBROUTINE FlowField_CopyExternalFieldType( SrcExternalFieldTypeData, DstExternalFieldTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(ExternalFieldType), INTENT(IN) :: SrcExternalFieldTypeData
   TYPE(ExternalFieldType), INTENT(INOUT) :: DstExternalFieldTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FlowField_CopyExternalFieldType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcExternalFieldTypeData%Vel)) THEN
  i1_l = LBOUND(SrcExternalFieldTypeData%Vel,1)
  i1_u = UBOUND(SrcExternalFieldTypeData%Vel,1)
  i2_l = LBOUND(SrcExternalFieldTypeData%Vel,2)
  i2_u = UBOUND(SrcExternalFieldTypeData%Vel,2)
  IF (.NOT. ALLOCATED(DstExternalFieldTypeData%Vel)) THEN 
    ALLOCATE(DstExternalFieldTypeData%Vel(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstExternalFieldTypeData%Vel.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstExternalFieldTypeData%Vel = SrcExternalFieldTypeData%Vel
ENDIF
 END SUBROUTINE FlowField_CopyExternalFieldType

 SUBROUTINE FlowField_DestroyExternalFieldType( ExternalFieldTypeData, ErrStat, ErrMsg, DEALLOCATEpointers )
  TYPE(ExternalFieldType), INTENT(INOUT) :: ExternalFieldTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL,INTENT(IN   ) :: DEALLOCATEpointers
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  LOGICAL                        :: DEALLOCATEpointers_local
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FlowField_DestroyExternalFieldType'

  ErrStat = ErrID_None
  ErrMsg  = ""

  IF (PRESENT(DEALLOCATEpointers)) THEN
     DEALLOCATEpointers_local = DEALLOCATEpointers
  ELSE
     DEALLOCATEpointers_local = .true.
  END IF
  
IF (ALLOCATED(ExternalFieldTypeData%Vel)) THEN
  DEALLOCATE(ExternalFieldTypeData%Vel)
ENDIF
 END SUBROUTINE FlowField_DestroyExternalFieldType

 SUBROUTINE FlowField_PackExternalFieldType( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(ExternalFieldType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'FlowField_PackExternalFieldType'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz   = Int_BufSz   + 1     ! Vel allocated yes/no
  IF ( ALLOCATED(InData%Vel) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! Vel upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Vel)  ! Vel
  END IF
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

  IF ( .NOT. ALLOCATED(InData%Vel) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vel,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vel,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vel,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vel,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%Vel,2), UBOUND(InData%Vel,2)
        DO i1 = LBOUND(InData%Vel,1), UBOUND(InData%Vel,1)
          ReKiBuf(Re_Xferred) = InData%Vel(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
 END SUBROUTINE FlowField_PackExternalFieldType

 SUBROUTINE FlowField_UnPackExternalFieldType( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(ExternalFieldType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'FlowField_UnPackExternalFieldType'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Vel not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Vel)) DEALLOCATE(OutData%Vel)
    ALLOCATE(OutData%Vel(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vel.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%Vel,2), UBOUND(OutData%Vel,2)
        DO i1 = LBOUND(OutData%Vel,1), UBOUND(OutData%Vel,1)
          OutData%Vel(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
 END SUBROUTINE FlowField_UnPackExternalFieldType

 SUBROUTINE FlowField_CopyUserFieldType( SrcUserFieldTypeData, DstUserFieldTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(UserFieldType), INTENT(IN) :: SrcUserFieldTypeData
   TYPE(UserFieldType), INTENT(INOUT) :: DstUserFieldTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FlowField_CopyUserFieldType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstUserFieldTypeData%Dummy = SrcUserFieldTypeData%Dummy
 END SUBROUTINE FlowField_CopyUserFieldType

 SUBROUTINE FlowField_DestroyUserFieldType( UserFieldTypeData, ErrStat, ErrMsg, DEALLOCATEpointers )
  TYPE(UserFieldType), INTENT(INOUT) :: UserFieldTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL,INTENT(IN   ) :: DEALLOCATEpointers
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  LOGICAL                        :: DEALLOCATEpointers_local
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FlowField_DestroyUserFieldType'

  ErrStat = ErrID_None
  ErrMsg  = ""

  IF (PRESENT(DEALLOCATEpointers)) THEN
     DEALLOCATEpointers_local = DEALLOCATEpointers
  ELSE
     DEALLOCATEpointers_local = .true.
  END IF
  
 END SUBROUTINE FlowField_DestroyUserFieldType

 SUBROUTINE FlowField_PackUserFieldType( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(UserFieldType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'FlowField_PackUserFieldType'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Re_BufSz   = Re_BufSz   + 1  ! Dummy
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    ReKiBuf(Re_Xferred) = InData%Dummy
    Re_Xferred = Re_Xferred + 1
 END SUBROUTINE FlowField_PackUserFieldType

 SUBROUTINE FlowField_UnPackUserFieldType( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(UserFieldType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'FlowField_UnPackUserFieldType'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    OutData%Dummy = REAL(ReKiBuf(Re_Xferred), SiKi)
    Re_Xferred = Re_Xferred + 1
 END SUBROUTINE FlowField_UnPackUserFieldType

 SUBROUTINE FlowField_CopyFlowFieldType( SrcFlowFieldTypeData, DstFlowFieldTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FlowFieldType), INTENT(IN) :: SrcFlowFieldTypeData
   TYPE(FlowFieldType), INTENT(INOUT) :: DstFlowFieldTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FlowField_CopyFlowFieldType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstFlowFieldTypeData%FieldType = SrcFlowFieldTypeData%FieldType
    DstFlowFieldTypeData%RefPosition = SrcFlowFieldTypeData%RefPosition
    DstFlowFieldTypeData%PropagationDir = SrcFlowFieldTypeData%PropagationDir
    DstFlowFieldTypeData%VFlowAngle = SrcFlowFieldTypeData%VFlowAngle
    DstFlowFieldTypeData%RotateWindBox = SrcFlowFieldTypeData%RotateWindBox
    DstFlowFieldTypeData%RotToWind = SrcFlowFieldTypeData%RotToWind
    DstFlowFieldTypeData%RotFromWind = SrcFlowFieldTypeData%RotFromWind
      CALL FlowField_Copyuniformfieldtype( SrcFlowFieldTypeData%Uniform, DstFlowFieldTypeData%Uniform, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL FlowField_Copygridfieldtype( SrcFlowFieldTypeData%Grid, DstFlowFieldTypeData%Grid, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL FlowField_Copyuserfieldtype( SrcFlowFieldTypeData%User, DstFlowFieldTypeData%User, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL FlowField_Copyexternalfieldtype( SrcFlowFieldTypeData%External, DstFlowFieldTypeData%External, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE FlowField_CopyFlowFieldType

 SUBROUTINE FlowField_DestroyFlowFieldType( FlowFieldTypeData, ErrStat, ErrMsg, DEALLOCATEpointers )
  TYPE(FlowFieldType), INTENT(INOUT) :: FlowFieldTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL,INTENT(IN   ) :: DEALLOCATEpointers
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  LOGICAL                        :: DEALLOCATEpointers_local
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FlowField_DestroyFlowFieldType'

  ErrStat = ErrID_None
  ErrMsg  = ""

  IF (PRESENT(DEALLOCATEpointers)) THEN
     DEALLOCATEpointers_local = DEALLOCATEpointers
  ELSE
     DEALLOCATEpointers_local = .true.
  END IF
  
  CALL FlowField_Destroyuniformfieldtype( FlowFieldTypeData%Uniform, ErrStat2, ErrMsg2, DEALLOCATEpointers_local )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL FlowField_Destroygridfieldtype( FlowFieldTypeData%Grid, ErrStat2, ErrMsg2, DEALLOCATEpointers_local )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL FlowField_Destroyuserfieldtype( FlowFieldTypeData%User, ErrStat2, ErrMsg2, DEALLOCATEpointers_local )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL FlowField_Destroyexternalfieldtype( FlowFieldTypeData%External, ErrStat2, ErrMsg2, DEALLOCATEpointers_local )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE FlowField_DestroyFlowFieldType

 SUBROUTINE FlowField_PackFlowFieldType( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(FlowFieldType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'FlowField_PackFlowFieldType'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Int_BufSz  = Int_BufSz  + 1  ! FieldType
      Re_BufSz   = Re_BufSz   + SIZE(InData%RefPosition)  ! RefPosition
      Re_BufSz   = Re_BufSz   + 1  ! PropagationDir
      Re_BufSz   = Re_BufSz   + 1  ! VFlowAngle
      Int_BufSz  = Int_BufSz  + 1  ! RotateWindBox
      Re_BufSz   = Re_BufSz   + SIZE(InData%RotToWind)  ! RotToWind
      Re_BufSz   = Re_BufSz   + SIZE(InData%RotFromWind)  ! RotFromWind
   ! Allocate buffers for subtypes, if any (we'll get sizes from these) 
      Int_BufSz   = Int_BufSz + 3  ! Uniform: size of buffers for each call to pack subtype
      CALL FlowField_Packuniformfieldtype( Re_Buf, Db_Buf, Int_Buf, InData%Uniform, ErrStat2, ErrMsg2, .TRUE. ) ! Uniform 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! Uniform
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! Uniform
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! Uniform
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
      Int_BufSz   = Int_BufSz + 3  ! Grid: size of buffers for each call to pack subtype
      CALL FlowField_Packgridfieldtype( Re_Buf, Db_Buf, Int_Buf, InData%Grid, ErrStat2, ErrMsg2, .TRUE. ) ! Grid 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! Grid
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! Grid
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! Grid
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
      Int_BufSz   = Int_BufSz + 3  ! User: size of buffers for each call to pack subtype
      CALL FlowField_Packuserfieldtype( Re_Buf, Db_Buf, Int_Buf, InData%User, ErrStat2, ErrMsg2, .TRUE. ) ! User 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! User
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! User
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! User
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
      Int_BufSz   = Int_BufSz + 3  ! External: size of buffers for each call to pack subtype
      CALL FlowField_Packexternalfieldtype( Re_Buf, Db_Buf, Int_Buf, InData%External, ErrStat2, ErrMsg2, .TRUE. ) ! External 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! External
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! External
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! External
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    IntKiBuf(Int_Xferred) = InData%FieldType
    Int_Xferred = Int_Xferred + 1
    DO i1 = LBOUND(InData%RefPosition,1), UBOUND(InData%RefPosition,1)
      ReKiBuf(Re_Xferred) = InData%RefPosition(i1)
      Re_Xferred = Re_Xferred + 1
    END DO
    ReKiBuf(Re_Xferred) = InData%PropagationDir
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%VFlowAngle
    Re_Xferred = Re_Xferred + 1
    IntKiBuf(Int_Xferred) = TRANSFER(InData%RotateWindBox, IntKiBuf(1))
    Int_Xferred = Int_Xferred + 1
    DO i2 = LBOUND(InData%RotToWind,2), UBOUND(InData%RotToWind,2)
      DO i1 = LBOUND(InData%RotToWind,1), UBOUND(InData%RotToWind,1)
        ReKiBuf(Re_Xferred) = InData%RotToWind(i1,i2)
        Re_Xferred = Re_Xferred + 1
      END DO
    END DO
    DO i2 = LBOUND(InData%RotFromWind,2), UBOUND(InData%RotFromWind,2)
      DO i1 = LBOUND(InData%RotFromWind,1), UBOUND(InData%RotFromWind,1)
        ReKiBuf(Re_Xferred) = InData%RotFromWind(i1,i2)
        Re_Xferred = Re_Xferred + 1
      END DO
    END DO
      CALL FlowField_Packuniformfieldtype( Re_Buf, Db_Buf, Int_Buf, InData%Uniform, ErrStat2, ErrMsg2, OnlySize ) ! Uniform 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      CALL FlowField_Packgridfieldtype( Re_Buf, Db_Buf, Int_Buf, InData%Grid, ErrStat2, ErrMsg2, OnlySize ) ! Grid 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      CALL FlowField_Packuserfieldtype( Re_Buf, Db_Buf, Int_Buf, InData%User, ErrStat2, ErrMsg2, OnlySize ) ! User 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      CALL FlowField_Packexternalfieldtype( Re_Buf, Db_Buf, Int_Buf, InData%External, ErrStat2, ErrMsg2, OnlySize ) ! External 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
 END SUBROUTINE FlowField_PackFlowFieldType

 SUBROUTINE FlowField_UnPackFlowFieldType( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(FlowFieldType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'FlowField_UnPackFlowFieldType'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    OutData%FieldType = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    i1_l = LBOUND(OutData%RefPosition,1)
    i1_u = UBOUND(OutData%RefPosition,1)
    DO i1 = LBOUND(OutData%RefPosition,1), UBOUND(OutData%RefPosition,1)
      OutData%RefPosition(i1) = ReKiBuf(Re_Xferred)
      Re_Xferred = Re_Xferred + 1
    END DO
    OutData%PropagationDir = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%VFlowAngle = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%RotateWindBox = TRANSFER(IntKiBuf(Int_Xferred), OutData%RotateWindBox)
    Int_Xferred = Int_Xferred + 1
    i1_l = LBOUND(OutData%RotToWind,1)
    i1_u = UBOUND(OutData%RotToWind,1)
    i2_l = LBOUND(OutData%RotToWind,2)
    i2_u = UBOUND(OutData%RotToWind,2)
    DO i2 = LBOUND(OutData%RotToWind,2), UBOUND(OutData%RotToWind,2)
      DO i1 = LBOUND(OutData%RotToWind,1), UBOUND(OutData%RotToWind,1)
        OutData%RotToWind(i1,i2) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
    END DO
    i1_l = LBOUND(OutData%RotFromWind,1)
    i1_u = UBOUND(OutData%RotFromWind,1)
    i2_l = LBOUND(OutData%RotFromWind,2)
    i2_u = UBOUND(OutData%RotFromWind,2)
    DO i2 = LBOUND(OutData%RotFromWind,2), UBOUND(OutData%RotFromWind,2)
      DO i1 = LBOUND(OutData%RotFromWind,1), UBOUND(OutData%RotFromWind,1)
        OutData%RotFromWind(i1,i2) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
    END DO
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL FlowField_Unpackuniformfieldtype( Re_Buf, Db_Buf, Int_Buf, OutData%Uniform, ErrStat2, ErrMsg2 ) ! Uniform 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL FlowField_Unpackgridfieldtype( Re_Buf, Db_Buf, Int_Buf, OutData%Grid, ErrStat2, ErrMsg2 ) ! Grid 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL FlowField_Unpackuserfieldtype( Re_Buf, Db_Buf, Int_Buf, OutData%User, ErrStat2, ErrMsg2 ) ! User 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL FlowField_Unpackexternalfieldtype( Re_Buf, Db_Buf, Int_Buf, OutData%External, ErrStat2, ErrMsg2 ) ! External 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
 END SUBROUTINE FlowField_UnPackFlowFieldType

END MODULE FlowField_Types
!ENDOFREGISTRYGENERATEDFILE
